---
title: 求解一组数中的最大矩形
date: 2016-05-20 15:36:58
tags: [算法, leetcode]
---

# 问题说明

将一组数想象成宽为1的矩形拼接而成的直方图, 求解直方图区域下最大的矩形面积

	比如:
	[1, 2, 3, 4, 5, 6]
	最大的直方就是[3-6]*4 或者 [4-6]*4为12
	[1, 1, 1, 5, 1]
	最大直方就是 1*5 = 5
	...

# 解法分析

## 方案1——BruteForce

解法说明:  

	1. 依次取出每一个数
	2. 从这个数的当前位置向前,向后搜索最大的"涵盖"这个数大小的范围(如果该数为4, 则5涵盖该数)
	3. 计算当前的面积,跟最大的面积做比较
	4. 重复上面3步,得到最大的面积

解法分析:  

	1. 时间复杂度为O(n^2)
	2. 每一次的遍历都是全新的遍历,并没有产生任何有价值的信息来优化之后的遍历

## 方案2——波浪演进法

名字是我随便想的。

解法思想:

	想象一下一种特定的数据状态:
	当前直方图除了最后一个直方前面的都是上升状态
	[1, 2, 3, 4, 5, x]
	这种状态下计算前面1-5的最大面积只要依次取出1-5并往后计算然后比较就能找出最大面积的直方了

	所以在另外一个结构中维持一个对应的波浪数据,就能够对应的计算出最大的直方面积了.

解法理解:  

	抽象的说,
	算法一直在记录一个数据变化的趋势,只要维持这个趋势成立,那么最大的直方肯定会出现在以某个直方开头之后的部分.
	这样就避免了暴力算法中的需要同时向前向后搜索的情况出现,
	同时这种算法会将中间的"特别高"的部分提前剔除掉，减少了很多不必要的计算

解法分析:
	1. 复杂度为O(n)

解法示例代码:
```
function countLargest($arr)
{
	$arr[] = 0;	//方便弹出计算包含最后一个矩形的面积
	$max_area = 0;

	$stack = [];
	foreach ($arr as $k=>$v) {
		$pop_pos = -1;
		while ( end($stack) && $arr[end($stack)] >= $v) {
			$pop_pos = array_pop($stack);
			$pop_value = $arr[$pop_pos];

			$tmp_area = $pop_value * ($k-$pop_pos);
			
			if ($tmp_area > $max_area) {
				$max_area = $tmp_area;
			}
		}
		if ($pop_pos > -1) {
			$arr[$pop_pos] = $v;
			$k = $pop_pos;
		}
		
		array_push($stack, $k);
	}

	return $max_area;
}
```

# 总结
 - 算法比较巧妙, 可以大概品味存个档

# 引申
 - 求解矩阵中的最大全1的矩形面积
