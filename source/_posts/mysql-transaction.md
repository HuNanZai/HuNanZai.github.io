---
title: 事务问题研究
date: 2016-05-09 10:06:50
tags: [mysql, 事务]
---

# 背景

假如需要更新用户的一笔金额到另一个用户的账户，并且中间的任何一个环节都不能出错，如果出错则视为本次转账失败，那么怎么去保证这个流程的稳定？

中间涉及到的一些过程:

	1. 锁定用户账户中的这笔钱
	2. 检查另一个账户是否存在
	3. 更新另一个账户
	4. 更新成功，扣除这个账户的钱
	5. 记录相关的log

如果按照上面的这种流程，在并发的环境下很容易出现各种问题:

	1. 另一个账户可能被转入很多笔重复的钱
	2. 另一个账户的钱更新成功，但是此时这个账户已经没有足够的金额扣款(出现负数)

# 并发下引起的问题
	1. 脏读
	2. 不可重复读
	3. 幻读

考虑一下两个流程

## 1. 脏读
	一个事务读取到了另一个事务没有提交的数据(还保存在内存中的"脏"数据)

详细解释:  

	1. 一个事务正在访问数据，并且对数据做了修改，而且这个修改还没有提交到数据库中(没有flush到log文件中)
	2. 而另一个事务也访问这个数据,从而使用了内存中更新了但是还没有提交的已经修改的数据,那么这个数据就是脏数据(依据这种数据来做的操作都是不可靠的,因为你还不知道提交是否成功)

## 2. 不可重复读
	在同一事务中，两次读取同一数据，得到的内容不同

详细解释:  

	1. 一个事务前后有两次对于同一个资源的读取
	2. 另一个事务正好在这个期间访问这个资源并作了修改
	3. 前一个事务前后两次读取资源可能因为步骤2不一样

## 3. 幻读
	事务A读取与搜索条件相匹配的若干行.事务B以插入或删除行等方式来修改事务A的结果集，然后再提交.

详细解释:  

	1. 一个事务进行一个范围的数据更新
	2. 另一个事务进行一个在步骤1范围内的数据插入(但是没有更新)
	3. 于是在步骤1执行完成之后数据库中仍有更新失败的数据(幻觉出现,其实是由并发的步骤2产生的)

# 解决方案目标

想办法加上各种锁

# 自己 的解决方案

## 设计上解耦

- 加上中间结果的记录表(账户出账表以及进账表)

## 代码上处理

- 在更新之前将所有涉及的数据先取出来存放(或者直接改为缓存存放)  

两种设计都还是不能解决根本的问题,并发的时候的请求还是会导致数据库数据错乱。

# Mysql 的解决方案——事务以及各种锁

## 事务

### 定义
	一组连续的数据库操作. 要么全部执行成功,要么全部失败.

### 特性:ACID
	A原子性: 要么全部执行成功,要不都不执行(执行到一半发生错误则回滚)
	C一致性: 事务的执行不能改变数据库数据的一致
	I独立性: 两个及以上的事务不会出现交错执行的状态
	D持久性: 事务执行成功之后对于数据库的改动持久的保存在数据库中,不会无缘无故回滚

### 使用样例
```mysql
//set AUTOCOMMIT = false;

start transaction;

//sql
update `xxx` set `xxx`='xxx' where `xx`='xx' limit 1;

...

commit/rollback;
```

## 各种锁  

根据数据操作类型:  

 - 读锁
 - 写锁

锁定数据的范围:  

 - 表锁
 - 行锁


